unit RRB;

@use "DMA"
@use "mega65"

var const GOTOX : byte = $10;
	const TRANSPARENT : byte = $80;
	const MAXSPRITE : byte = 31;
	const TRANSPARENT_SPRITE : integer = 2048;
	spriteData : array[MAXSPRITE] of integer;
	spriteBank : array[MAXSPRITE] of byte;
	spriteTile : array[MAXSPRITE] of integer;
	spriteX : array[MAXSPRITE] of integer;
	spriteY : array[MAXSPRITE] of integer;
	rLogSprRow : array[MAXSPRITE] of integer;
	spriteLastRow : array[MAXSPRITE] of byte;
	lastSprite : byte = 0;
	addr : integer;
	
	tileLayerAddr : integer;
	tileLayerBank : byte;
	tileLayerWidth : integer;
	tileLayerBase : integer;
	
	@donotremove screenMap
	screenMap : array[5100] of byte at $3000;	// reserve screen map data for rrb

procedure copySpriteTileOffset(tilenum : integer;_offset : byte;sprData:integer);
begin
	// erase 2 tiles (tilenum, tilenum + 1)
	// lfill(dmb1:byte;db1:byte;daddr1:integer;value1:byte;count2:integer)
	DMA::lfill(0,2,tilenum*64,0,128);
	
	// copy sprite tile data with offset (_offset) to this space
	// Sprite Data at $1F000
	
	DMA::lcopy(0,1,sprData,0,2,tilenum*64 + _offset*8,64);
	
end;


function addSpriteLayer(_spriteTile : integer;sprDBank : byte;_sprData: integer) : byte;
begin
	if (lastSprite < MAXSPRITE) then
	begin
		spriteX[lastSprite] := 0;
		spriteY[lastSprite] := 0;
		spriteData[lastSprite] := _sprData;
		spriteBank[lastSprite] := sprDBank;
		spriteTile[lastSprite] := _spriteTile+2047;
		spriteLastRow[lastSprite] := 0;
		lastSprite := lastSprite + 1;
		addSpriteLayer := lastSprite-1;
	end;
end;

procedure addTileLayer(madrBank : byte;mapAddress : integer; mapWidth : integer; tileBase : integer);
begin
	tileLayerAddr := mapAddress;
	tileLayerBank := madrBank;
	tileLayerWidth := mapWidth;
	tileLayerBase := tileBase;
end;


procedure UpdateSprite(spriteNum : byte);
var 
		sprYOffset : byte;
		sprY : byte;
		sprNum : integer;
		lastRow : byte;
begin
	lastRow := spriteLastRow[spriteNum];
	sprNum := spriteNum * 4;
	sprYOffset := mod(spriteY[spriteNum],8);
	sprY := spriteY[spriteNum] / 8;
	
	addr := 80 + rLogSprRow[lastRow] + sprNum + 2;
	
	// clear sprite row and row+1 
	DMA::poke16($0005,addr,2047);
	addr := addr + mega65::LogicalRowSize;
	DMA::poke16($0005,addr,2047);
	
	copySpriteTileOffset(spriteTile[spriteNum],sprYOffset,spriteData[spriteNum]);
	
	spriteLastRow[spriteNum] := sprY;
	
	addr := 80 + rLogSprRow[sprY] + sprNum;
	DMA::poke16($0005,addr,spriteX[spriteNum]);
	addr := addr + 2;
	DMA::poke16($0005,addr,spriteTile[spriteNum]);
	
	addr := addr + mega65::LogicalRowSize - 2;
	DMA::poke16($0005,addr,spriteX[spriteNum]);
	addr := addr + 2;
	DMA::poke16($0005,addr,spriteTile[spriteNum]+1);
	
end;

procedure CreateRRB();
var	row : byte;
	dummy : integer;
	tx : byte;
	taddr : integer;

	sprite : byte;
begin
	if (lastSprite > 0) then
	begin
		row := 40 + lastSprite * 2 + 2;
		mega65::SetRowSize(row);
	end else
	begin
		mega65::SetRowSize(40);
	end;

	dummy := 0;
	for row := 0 to 25 do
	begin
		// save the beginning of each row for later
		rLogSprRow[row] := dummy;
		
		// advance the source map layer pointer 
		taddr := tileLayerAddr + (row * 2) * tileLayerWidth;
		
		// advance the screen pointer
		addr := $0000 + dummy;

		dummy := dummy + mega65::LogicalRowSize;

		// Draw Tile Layer
		for tx := 0 to tileLayerWidth do
		begin	
			// copy 2 bytes from tilemap address to screen addresstable(,,);
			DMA::lcopy($00,tileLayerBank,taddr,$00,$05,addr,2);
			taddr := taddr + 2;
			addr := addr + 2;
		end;
		
		if (lastSprite > 0) then
		begin
			
			sprite := 0;
			while (sprite<lastSprite) do
			begin
				// GOTOX
				DMA::poke16($0ff8,addr,$90);
				DMA::poke16($0005,addr,0);
				addr := addr + 2;
				// SPRITE
				DMA::poke16($0ff8,addr,0);
				DMA::poke16($0005,addr,2047);
				addr := addr + 2;
				sprite := sprite + 1;
			end;
		
			// GOTOX - 320

			DMA::poke16($0ff8,addr,$90);
			DMA::poke16($0005,addr,$140);
			
			addr := addr + 2;
			
			// Finish Char
			DMA::poke16($0ff8,addr,0);
			DMA::poke16($0005,addr,0);
		end;
	end;
end;

end.