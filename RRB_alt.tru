unit RRB_alt;

@use "DMA"
@use "mega65"

var const GOTOX : byte = $10;
	const TRANSPARENT : byte = $80;
	const MAXSPRITE : byte = 31;
	const TRANSPARENT_SPRITE : integer = 2048;
	spriteData : array[MAXSPRITE] of integer;
	spriteBank : array[MAXSPRITE] of byte;
	spriteTile : array[MAXSPRITE] of integer;
	spriteX : array[MAXSPRITE] of integer;
	spriteY : array[MAXSPRITE] of integer;
	rLogSprRow : array[MAXSPRITE] of integer;
	spriteLastRow : array[MAXSPRITE] of byte;
	lastSprite : byte = 0;
	addr : integer;
	
	tileLayerAddr : integer;
	tileLayerBank : byte;
	tileLayerWidth : integer;
	tileLayerBase : integer;
	
	@donotremove screenMap
	@donotremove colorMap
	screenMap : array[1550] of byte at $5000;		// reserve screen map data for rrb 30 sprites 치 4 Byte + 4 byte end * 25 rows
	colorMap : array[1550] of byte at $560F;		// reserve color map data for rrb 30 sprites 치 4 Byte + 4 byte end * 25 rows
	rrbMapSt : array[25] of integer;				// startaddress of rrb (lower 2 bytes)
	rrbMaxLen : integer;							// length of rrb line
	mapP : ^integer;								// pointer for mapArray
	clrP : ^integer;								// pointer for clrArray
	
procedure copySpriteTileOffset(tilenum : integer;_offset : byte;sprData:integer);
begin
	// erase 2 tiles (tilenum, tilenum + 1)
	// lfill(dmb1:byte;db1:byte;daddr1:integer;value1:byte;count2:integer)
	DMA::lfill(0,2,tilenum*64,0,128);
	
	// copy sprite tile data with offset (_offset) to this space
	// Sprite Data at $1F000
	
	DMA::lcopy(0,1,sprData,0,2,tilenum*64 + _offset*8,64);
	
end;


function addSpriteLayer(_spriteTile : integer;sprDBank : byte;_sprData: integer) : byte;
begin
	if (lastSprite < MAXSPRITE) then
	begin
		spriteX[lastSprite] := 0;
		spriteY[lastSprite] := 0;
		spriteData[lastSprite] := _sprData;
		spriteBank[lastSprite] := sprDBank;
		spriteTile[lastSprite] := _spriteTile+2047;
		spriteLastRow[lastSprite] := 0;
		lastSprite := lastSprite + 1;
		addSpriteLayer := lastSprite-1;
	end;
end;

procedure addTileLayer(madrBank : byte;mapAddress : integer; mapWidth : integer; tileBase : integer);
begin
	// lfill(dmb1:byte;db1:byte;daddr1:integer;value1:byte;count2:integer) ;
	//DMA::lfill(0,0,#screenMap,$22,5100);
	tileLayerAddr := mapAddress;
	tileLayerBank := madrBank;
	tileLayerWidth := mapWidth;
	tileLayerBase := tileBase;
end;


procedure UpdateSprite(spriteNum : byte);
var 
		sprYOffset : byte;
		sprY : byte;
		sprNum : integer;
		lastRow : byte;
begin
	/*lastRow := spriteLastRow[spriteNum];
	sprNum := spriteNum * 4;
	sprYOffset := mod(spriteY[spriteNum],8);
	sprY := spriteY[spriteNum] / 8;
	
	addr := 80 + rLogSprRow[lastRow] + sprNum + 2;
	
	// clear sprite row and row+1 
	DMA::poke16($0005,addr,2047);
	addr := addr + mega65::LogicalRowSize;
	DMA::poke16($0005,addr,2047);
	
	copySpriteTileOffset(spriteTile[spriteNum],sprYOffset,spriteData[spriteNum]);
	
	spriteLastRow[spriteNum] := sprY;
	
	addr := 80 + rLogSprRow[sprY] + sprNum;
	DMA::poke16($0005,addr,spriteX[spriteNum]);
	addr := addr + 2;
	DMA::poke16($0005,addr,spriteTile[spriteNum]);
	
	addr := addr + mega65::LogicalRowSize - 2;
	DMA::poke16($0005,addr,spriteX[spriteNum]);
	addr := addr + 2;
	DMA::poke16($0005,addr,spriteTile[spriteNum]+1);*/
	
end;

procedure CreateRRB();
var	row : byte;
	dummy : integer;
	tx : byte;
	taddr : integer;
	rrbCount : integer;

	sprite : byte;
begin
	if (lastSprite > 0) then
	begin
		row := 40 + lastSprite * 2 + 2;
		rrbMaxLen := lastSprite * 2 + 2;		// 2 integer per sprite + 2 integer end char
		mega65::SetRowSize(row);
	end else
	begin
		mega65::SetRowSize(40);
	end;

	dummy := 0;
	for row := 0 to 25 do
	begin
		// save the beginning of each row for later
		rLogSprRow[row] := dummy;
		
		// advance the source map layer pointer 
		taddr := tileLayerAddr + (row * 2) * tileLayerWidth;
		
		// advance the screen pointer
		addr := $0000 + dummy;

		dummy := dummy + mega65::LogicalRowSize;

		// Draw Tile Layer
		for tx := 0 to tileLayerWidth do
		begin	
			// copy 2 bytes from tilemap address to screen addresstable(,,);
			DMA::lcopy($00,tileLayerBank,taddr,$00,$05,addr,2);
			taddr := taddr + 2;
			addr := addr + 2;
		end;
		
		if (lastSprite > 0) then
		begin
			/* 	screenMap : array[3100] of byte at $5000;	// reserve screen map data for rrb 30 sprites 치 4 Byte + 4 byte end * 25 rows
				colorMap : array[3100] of byte at $5C1D;	// reserve color map data for rrb 30 sprites 치 4 Byte + 4 byte end * 25 rows
				rrbMapSt : array[25] of integer;			// startaddress of rrb (lower 2 bytes)
			*/
			
			sprite := 0;
		
			mapP := #screenMap + row*rrbMaxLen;
			clrP := #colorMap + row*rrbMaxLen;			
			rrbMapSt[row] := row*rrbMaxLen;
			
			while (sprite<lastSprite) do
			begin
				
				mapP^ := 0;
				clrP^ := $90;
				
				mapP := mapP + 1;
				clrP := clrP + 1;
				
				mapP^ := 0;
				clrP^ := 0;
				
				mapP := mapP + 1;
				clrP := clrP + 1;

				mapP^ := lo(2047);
				clrP^ := 0;
				
				mapP := mapP + 1;
				clrP := clrP + 1;
								
								
				mapP^ := hi(2047);
				clrP^ := $0;
				
				mapP := mapP + 1;
				clrP := clrP + 1;
				
				sprite := sprite + 1;
/*				// GOTOX
				DMA::poke16($0ff8,addr,$90);
				DMA::poke16($0005,addr,0);
				addr := addr + 2;
				// SPRITE
				DMA::poke16($0ff8,addr,0);
				DMA::poke16($0005,addr,2047);
				addr := addr + 2;
				sprite := sprite + 1;*/
			end;
			mapP^ := lo($140);
			clrP^ := $10;
				
			mapP := mapP + 1;
			clrP := clrP + 1;

			mapP^ := hi($140);
			clrP^ := 0;
			
			mapP := mapP + 1;
			clrP := clrP + 1;
			
			mapP^ := $0;
			clrP^ := $0;
			
			mapP := mapP + 1;
			clrP := clrP + 1;
			
			mapP^ := $0;
			clrP^ := $0;
			
			// lcopy(smb:byte;sb:byte;saddr:integer;dmb:byte;db:byte;daddr:integer;count1:integer) ;
			DMA::lcopy(0,0,#screenMap+rrbMapSt[row],0,$05,addr,rrbMaxLen);
			DMA::lcopy(0,0,#colorMap+rrbMapSt[row],$0f,$f8,addr,rrbMaxLen);

/*			// GOTOX - 320

			DMA::poke16($0ff8,addr,$10);
			DMA::poke16($0005,addr,$140);
			
			addr := addr + 2;
			
			// Finish Char
			DMA::poke16($0ff8,addr,0);
			DMA::poke16($0005,addr,0);*/
		end;
	end;
end;

end.